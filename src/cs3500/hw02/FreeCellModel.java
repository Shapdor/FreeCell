package cs3500.hw02;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/* -----------CHANGES FOR HW04 SUBMISSION-----------
 *
 * - Had to refactor ALoPile's move method to the model's move method as it contained code
 * that restrained it to only being able to move a single card at the end of a pile. NOTE:
 * no code was changed, just moved all the code from that method to this class' move method.
 *
 * - Changed permissions of model's class fields to protected from package-private, as the subclass
 * MultiMoveFreeCellModel was not able to access the inherited fields.
 *
 * - Misc changes from package-private to protected to grant MultiMoveFreeCellModel permissions.
 */

/**
 * To represent a FreeCell Model - all the logical operations of the game.
 */
public class FreeCellModel implements IFreeCellModel<Card> {
  protected List<Card> deck;
  protected Cascades cascades;
  protected Foundations foundations;
  protected Opens opens;

  /**
   * A default constructor initializing all fields of the model to their default values. Sets
   * the deck equal to the default deck generated by {@code getDeck} and the different playing
   * fields to empty lists.
   */
  public FreeCellModel() {
    this.deck = this.getDeck();
    this.cascades = new Cascades(0);
    this.foundations = new Foundations(0);
    this.opens = new Opens(0);
  }

  /**
   * Generates a standard non-shuffled 52-card deck by iterating through all possible combinations
   * of suits and values.
   *
   * @return a standard deck with 52 unique cards
   */
  @Override
  public List<Card> getDeck() {
    List<Card> deck = new ArrayList<>();
    for (Card.CardSuit suit : Card.CardSuit.values()) {
      for (Card.CardValue value : Card.CardValue.values()) {
        deck.add(new Card(value, suit));
      }
    }
    return deck;
  }

  /**
   * Starts the game of Freecell.
   *
   * <p>First checks if given give deck is valid and if the number of open and cascade piles is
   * valid. If shuffle is true, shuffles the given deck before dealing. After creating piles,
   * deals the cards in the given deck to the cascade piles in the round-robin fashion.</p>
   *
   * <p>The game must have at least 1 open pile and 4 cascades.</p>
   *
   * @param deck            the deck to be dealt, uses default deck if given {@code null}
   * @param numCascadePiles number of cascade piles
   * @param numOpenPiles    number of open piles
   * @param shuffle         if true, shuffle the deck else deal the deck as-is
   * @throws IllegalArgumentException if the deck is invalid
   * @throws IllegalArgumentException if number of cascades or open piles is invalid
   *
   */
  @Override
  public void startGame(List<Card> deck, int numCascadePiles, int numOpenPiles, boolean shuffle)
          throws IllegalArgumentException, ArrayIndexOutOfBoundsException {

    if (numCascadePiles < 4 || numOpenPiles < 1) {
      throw new IllegalArgumentException("Invalid number of piles.");
    }
    if (deck == null) {
      this.deck = getDeck();
    }
    else {
      this.deck = deck;
    }
    if (shuffle) {
      Collections.shuffle(this.deck);
    }
    if (!(this.deckIsValid())) {
      throw new IllegalArgumentException("Invalid deck.");
    }

    this.cascades = new Cascades(numCascadePiles);
    this.foundations = new Foundations(4);
    this.opens = new Opens(numOpenPiles);

    for (int i = 0; i < this.deck.size(); i++) {
      Pile currPile = this.cascades.piles.get(i % this.cascades.piles.size());
      currPile.cards.add(this.deck.get(i));
    }
  }


  /**
   * Move a card from the given source pile to the given destination pile, if the move is valid.
   *
   * @param sourceType                the type of the source pile (see {@link PileType})
   * @param sourcePileNumber          the pile number of the given type, starting at 0
   * @param cardIndex                 the index of the card to be moved from the source
   *                                  pile, starting at 0
   * @param destType                  the type of the destination pile (see {@link PileType})
   * @param destPileNumber            the pile number of the given type, starting at 0
   * @throws IllegalArgumentException if the pile type is invalid
   * @throws IllegalArgumentException if the move is not possible
   */
  @Override
  public void move(PileType sourceType, int sourcePileNumber, int cardIndex, PileType destType,
                   int destPileNumber)
          throws IllegalArgumentException {
    ALoPile sourcePiles = PileType.getModelField(this, sourceType);

    if (sourcePileNumber >= sourcePiles.piles.size()) {
      throw new IndexOutOfBoundsException("Invalid pile index.");
    }
    Pile sourcePile = sourcePiles.piles.get(sourcePileNumber);

    if (sourcePile.cards.isEmpty() || sourcePile.cards.size() - 1 != cardIndex) {
      throw new IllegalArgumentException("no card at this index or not the last card in pile");
    }

    Card workingCard = sourcePile.cards.get(cardIndex);

    ALoPile destPiles = PileType.getModelField(this, destType);

    if (destPileNumber >= destPiles.piles.size()) {
      throw new IndexOutOfBoundsException("Invalid pile index.");
    }

    Pile destPile = destPiles.piles.get(destPileNumber);
    if (destPile.equals(sourcePile)) {
      return;
    }

    destPiles.processMove(workingCard, destPileNumber);

    // If this is reached the move was successful
    sourcePile.cards.remove(cardIndex);
  }

  /**
   * Determines whether the game is over or not by checking if the cascades are empty, if the
   * open piles are empty, and if all the foundations have kings on top. If all these conditions
   * are met, the game is over.
   *
   * @return true if the game is over, false otherwise
   */
  @Override
  public boolean isGameOver() {
    return this.cascades.isGameOver() && this.opens.isGameOver() && this.foundations.isGameOver();
  }

  /**
   * Return the state of the game as a formatted string with all the piles and their contents.
   *
   * @return the current state of the game
   */
  @Override
  public String getGameState() {
    StringBuilder output = new StringBuilder();

    output.append(this.foundations.toGameStateString());
    output.append(this.opens.toGameStateString());
    output.append(this.cascades.toGameStateString());

    return output.toString().trim();
  }

  private boolean deckIsValid() {
    Set<Card> set = new HashSet<Card>(this.deck);
    boolean hasDuplicates = set.size() < this.deck.size();
    return !(hasDuplicates) && this.deck.size() == 52;
  }

}
